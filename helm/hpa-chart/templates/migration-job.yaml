{{- if .Values.backend.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "hpa-chart.fullname" . }}-migrations-{{ .Release.Revision }}
  labels:
    {{- include "hpa-chart.labels" . | nindent 4 }}
    app.kubernetes.io/component: migrations
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  backoffLimit: 3
  activeDeadlineSeconds: 600
  template:
    metadata:
      labels:
        {{- include "hpa-chart.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: migrations
    spec:
      restartPolicy: OnFailure
      {{- with .Values.global.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      serviceAccountName: {{ include "hpa-chart.serviceAccountName" . }}
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
      initContainers:
        - name: wait-for-postgres
          image: busybox:1.35
          command: ['sh', '-c']
          args:
            - |
              echo "Waiting for PostgreSQL to be ready..."
              until nc -z {{ .Release.Name }}-postgresql 5432; do
                echo "PostgreSQL is not ready yet. Waiting..."
                sleep 2
              done
              echo "PostgreSQL is ready!"
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
      containers:
        - name: migrate
          image: "{{ .Values.backend.image.repository }}:{{ .Values.backend.image.tag | default .Chart.AppVersion }}"
          imagePullPolicy: {{ .Values.backend.image.pullPolicy }}
          command: ["/bin/sh", "-c"]
          args:
            - |
              set -euo pipefail
              
              echo "Starting database migration job..."
              
              # Create migrations tracking table if not exists
              psql "${DATABASE_URL}" <<-EOSQL
                CREATE TABLE IF NOT EXISTS schema_migrations (
                  version VARCHAR(255) PRIMARY KEY,
                  applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );
              EOSQL
              
              # Apply migrations in order
              for migration_file in /app/migrations/*.sql; do
                if [ -f "$migration_file" ] && [ -r "$migration_file" ]; then
                  migration_name=$(basename "$migration_file")
                  
                  # Validate migration filename format (NNNN_description.sql)
                  if ! echo "$migration_name" | grep -qE '^[0-9]{4}_[a-zA-Z0-9_]+\.sql$'; then
                    echo "ERROR: Invalid migration filename format: $migration_name"
                    echo "Expected format: NNNN_description.sql (e.g., 0001_initial_schema.sql)"
                    exit 1
                  fi
                  
                  # Sanitize migration name for logging
                  safe_migration_name=$(echo "$migration_name" | sed 's/[^a-zA-Z0-9._-]//g')
                  
                  # Check if migration was already applied using parameterized query
                  applied=$(psql -t -A "${DATABASE_URL}" \
                    -v v_migration="$safe_migration_name" \
                    -c "SELECT COUNT(*) FROM schema_migrations WHERE version = :'v_migration';")
                  
                  if [ "$applied" = "0" ]; then
                    echo "AUDIT: Starting migration $safe_migration_name at $(date -Iseconds)"
                    echo "Applying migration: $safe_migration_name"
                    
                    # Validate migration file size (prevent huge files)
                    file_size=$(stat -c%s "$migration_file" 2>/dev/null || stat -f%z "$migration_file" 2>/dev/null || echo "0")
                    if [ "$file_size" -gt 10485760 ]; then  # 10MB limit
                      echo "ERROR: Migration file too large: $safe_migration_name (${file_size} bytes)"
                      exit 1
                    fi
                    
                    # Apply migration with proper transaction handling
                    {
                      echo "BEGIN;"
                      cat "$migration_file"
                      echo ";"  # Ensure statement termination
                      # Use parameterized insert for migration tracking
                      echo "PREPARE insert_migration (text) AS INSERT INTO schema_migrations (version) VALUES (\$1);"
                      echo "EXECUTE insert_migration ('$safe_migration_name');"
                      echo "DEALLOCATE insert_migration;"
                      echo "COMMIT;"
                    } | psql "${DATABASE_URL}" -v ON_ERROR_STOP=1 --single-transaction
                    
                    if [ $? -eq 0 ]; then
                      echo "SUCCESS: Completed migration $safe_migration_name at $(date -Iseconds)"
                    else
                      echo "ERROR: Failed to apply migration: $safe_migration_name at $(date -Iseconds)"
                      exit 1
                    fi
                  else
                    echo "INFO: Skipping already applied migration: $safe_migration_name"
                  fi
                else
                  echo "WARNING: Unable to read migration file: $migration_file"
                fi
              done
              
              echo "All migrations completed successfully!"
              
              # Display migration status
              echo "Current migration status:"
              psql "${DATABASE_URL}" -c "SELECT version, applied_at FROM schema_migrations ORDER BY applied_at;"
          env:
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: {{ include "hpa-chart.fullname" . }}-backend
                  key: database-url
          volumeMounts:
            - name: migrations
              mountPath: /app/migrations
              readOnly: true
            - name: tmp
              mountPath: /tmp
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
            readOnlyRootFilesystem: true
          resources:
            limits:
              cpu: 500m
              memory: 256Mi
            requests:
              cpu: 100m
              memory: 128Mi
      volumes:
        - name: migrations
          configMap:
            name: {{ include "hpa-chart.fullname" . }}-migrations
        - name: tmp
          emptyDir: {}
{{- end }}